// https://github.com/whisky-shusuky/glsl_storage/blob/master/glsl/sakurahubuki.glsl

#version 330 core
out vec4 fragColor;

uniform vec3 iResolution;   // viewport resolution (in pixels)
uniform float iTime;        // shader playback time (in seconds)
uniform vec4 iMouse;        // xy: current (if MLB down), zw: click

precision highp float;

uniform vec2 mouse;
uniform sampler2D backbuffer;

float gTime = 0.;

// 回転行列
mat2 rot(float a) {
	float c = cos(a), s = sin(a);
	return mat2(c,s,-s,c);
}

// 円周率
const float pi = acos(-1.0);
const float pi2 = pi*2.;


float sdEllipsoid( in vec3 p, in vec3 r )
{
	float k0 = length(p/r);
	float k1 = length(p/(r*r));
	return k0*(k0-1.0)/k1;
}

float sdBox( vec3 p, vec3 b )
{
	vec3 q = abs(p) - b;
	return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);
}

float sakura(vec3 pos, float scale) {
	pos *= scale;
	float base = sdEllipsoid(pos, vec3(.4,.6,.2)) /1.5;
	pos.xy *= 5.;
	//pos.yz *= rot(.);
	pos.y -= 3.5;
	pos.xy *= rot(.75);
	float cut = sdBox(pos  , vec3(1.,1.,1.));
	float result = min(-base,cut) *2.;
	return result;
}

float sakura_set(vec3 pos) {
	vec3 pos_origin = pos;
	pos = pos_origin;
	pos .y -= .1;
	float sakura1 = sakura(pos,2.);
	pos = pos_origin;
	pos .x += .35;
	pos .y += .15;
	pos.xy *=   rot(.9);
	float sakura2 = sakura(pos,2.);
	pos = pos_origin;
	pos .x -= .35;
	pos .y += .15;
	pos.xy *=   rot(-.9);
	float sakura3 = sakura(pos,2.);	
	pos = pos_origin;
	pos .x += .225;
	pos .y += .6;
	pos.xy *=   rot(2.5);
	float sakura4 = sakura(pos,2.);	
	pos = pos_origin;
	pos .x -= .225;
	pos .y += .6;
	pos.xy *=   rot(-2.5);
	float sakura5 = sakura(pos,2.);	
	float result = max(max(max(max(sakura1,sakura2),sakura3),sakura4),sakura5);
	return result;
}

float map(vec3 pos) {
	vec3 pos_origin = pos;
	float sakura_set1 = sakura_set(pos);
	pos.x +=sin(gTime);
	pos.y +=sin(gTime);
	pos.z +=sin(gTime);
    pos.yz *= rot(sin(gTime * 2.)) * 2.;
	float sakura_set2 = sakura_set(pos);
	pos = pos_origin;
	pos.x -=sin(gTime);
	pos.y -=sin(gTime);
	pos.z -=sin(gTime);
    pos.yz *= rot(sin(gTime * 2.)) * 4.;
	float sakura_set3 = sakura_set(pos);
	pos = pos_origin;
	pos.x +=cos(gTime * 0.25);
	pos.y +=cos(gTime * 0.25);
	pos.z +=cos(gTime);
	pos.yz *= rot(cos(gTime)) * 4.;
	pos *= 1.5;
	float result = max(max(sakura_set1,sakura_set2),sakura_set3);

	return result;
}


void main( void ) {
	vec2 p = (gl_FragCoord.xy * 2. - iResolution.xy) / min(iResolution.x, iResolution.y);
	vec3 ro = vec3(0.5, sin(iTime) * 2.  + 0.3 ,iTime * 2.);
	vec3 ray = normalize(vec3(p, 1.5));

	float t = 0.01;
	vec3 col = vec3(0.);
	float ac = 0.0;

	//p = p * rot(iTime);
	ro.xy  =ro.xy * rot(iTime/ 5.) * .1;
	ro.yz  =ro.yz * rot(iTime/ 5.) * 0.005;

	for (int i = 0; i < 99; i++){
		vec3 pos = ro + ray * t;
		pos = mod(pos-2., 4.) -2.;
		gTime = iTime -float(i) * 0.01;
		pos.xy = pos.xy  * rot(iTime);
		
		pos.yz = pos.yz  * rot(sin(iTime) /2.);
		
		float d = map(pos);

		d = max(abs(d), 0.02);
		ac += exp(-d*3.);

		t += d* 0.15;
	}

	col = vec3(ac * 0.04);
	vec3 finalColor = vec3 ( 0., 0., 0. );

	col += smoothstep(0.5, 1.,sin(iTime)) * .15 * vec3 ( 1.0, 0.3, 0.5 );
	col += smoothstep(0.5, 1.,cos(iTime)) * .15 * vec3 ( .0, 0.3, 1.0 );

	col.z += + 0.54;
	col.y = col.y * abs(sin(iTime) / 4.) + 0.54;


	fragColor = vec4(col ,1.0);
}